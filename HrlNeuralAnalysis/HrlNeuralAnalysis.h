/*
    HRLAnalysis(TM) Software License - Version 1.0 - August 27th, 2013

    Permission is hereby granted, free of charge, to any person or 
    organization obtaining a copy of the software and accompanying 
    documentation covered by this license (the "Software") to use, 
    reproduce, display, distribute, execute, and transmit the 
    Software, and to prepare derivative works of the Software, and 
    to permit third-parties to whom the Software is furnished to do 
    so, all subject to the following:

    The copyright notices in the Software and this entire statement, 
    including the above license grant, this restriction and the 
    following disclaimer, must be included in all copies of the 
    Software, in whole or in part, and all derivative works of the 
    Software, unless such copies or derivative works are solely in 
    the form of machine-executable object code generated by a source 
    language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND 
    NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR 
    ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR 
    OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING 
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
    OTHER DEALINGS IN THE SOFTWARE, INCLUDING BUT NOT LIMITED TO THE 
    COMPATIBILITY OF THIS LICENSE WITH OTHER SOFTWARE LICENSES.
*/
#ifndef HRLNEURALANALYSIS_H
#define HRLNEURALANALYSIS_H

#include <boost/serialization/vector.hpp>
#include <boost/serialization/shared_ptr.hpp>
#include <boost/serialization/string.hpp>
#include <boost/serialization/utility.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>
#include <boost/foreach.hpp>
#include <boost/shared_ptr.hpp>
#include <assert.h>
#include <vector>
#include <string>
#include <iostream>
#include <fstream>
#include <numeric>
#include <math.h>
#include <NeuronParams.h>
#include <SynchronyInfo.h>
#include <RasterInfo.h>
#include <BurstInfo.h>
#include <CovInfo.h>
#include <RateInfo.h>
#include <CellRateInfo.h>
#include <RateBinInfo.h>
#include <CellRateBinInfo.h>

//#Defines for Burst Analysis
#define     MIN_BURST_SPIKE_COUNT   3
#define     MIN_BURST_SURPRISE      3

namespace boost {
namespace serialization {
	class access;
}
}

namespace hrlAnalysis {

typedef boost::shared_ptr<std::vector< std::pair<int,int> > > SpikeActivityPtr;
typedef boost::shared_ptr<std::vector< std::vector<int> > > CellActivityPtr;

class HrlNeuralAnalysis
{
    public:
		HrlNeuralAnalysis();
        /**
         * Base constructor
         *
         * @param startTimeIn the point in time to begin extracting spiking information.
         * @param endTimeIn when to stop extracting information.
         * @param startIdxIn the starting cell index for neurons to be extracted.
         * @param endIdxIn the last index of the neurons to be extracted.
         * @param fileNames the bin files containing the simulations results.
         */
        HrlNeuralAnalysis(int startTimeIn, int endTimeIn, int startIdxIn, int endIdxIn, std::vector<std::string> fileNames);
        /**
         * Base destructor
         */
        virtual ~HrlNeuralAnalysis();
        /**
         * Create the data structures used for analysis.  The spike times and neuron indexes,
         * within the specified ranges, are extracted from the given bin files.
         * @return Success
         */
        virtual bool buildDataStructures() = 0;

        virtual void save(std::string filename);

        virtual void load(std::string filename);

        /**
         * Output the spike activity (time,neuron index) stored in the data structures to stdout.
         */
        void dumpSpikeActivity();
        /**
         * Output the cell activity (cell, spike times) stored in the data structures to stdout.
         */
        void dumpCellActivity();
        /**
         * Get the bivarite SPIKE-Distance by numerically integrating the dissimilarity profile
         * with Simpson's Rule.
         *
         * @param[in] synchPtr stores the SPIKE-distance metric between two cells.
         *
         */
        double calcSPIKEDistance(SynchronyInfoPtr synchPtr);
        /**
         * Get the bivarite SPIKE-Distance by averaging the dissimilarity profile.
         *
         * @param[in] synchPtr stores the SPIKE-distance metric between two cells.
         *
         */
        double calcSPIKEDistanceAvg(SynchronyInfoPtr synchPtr);
        /**
         * Compute the Poisson surprise
         *
         * @param[in] t current time.
         * @param[in] nSpikes number of spikes
         * @param[in] rate overall activity rate.
         *
         */
        double calcSurprise(int t, int nSpikes, double rate);
        /**
         * Return a RasterInfoPtr containing the spiking information.
         */
        RasterInfoPtr getSpikeTimes();
        /**
         * Return a CovInfoPtr containing the coefficient of variation for each of the cells.
         */
        CovInfoPtr getCOV();
        /**
         * Return a RateInfoPtr containing the moving time averaged rate using a Gaussian window.
         *
         * @param[in] step how many time values to move the window during the calculations
         * @param[in] rateWindow window size in time values.
         */
        RateInfoPtr getGaussWindowRate(double step, double rateWindow);
        /**
         * Return a RateInfoPtr containing the moving time averaged rate using a square window.
         *
         * @param[in] step how many time values to move the window during the calculations
         * @param[in] rateWindow window sice in time values.
         */
        RateInfoPtr getWindowRate(double step, double rateWindow);
        /**
         * Return a CellRateInfoPtr containing each of the individual cell total-time average spike rates.
         */
        CellRateInfoPtr getCellRates();
        /**
         * Return a RateBinInfoPtr containing the number of cells that fall into discrete rate bins.
         * @param[in] numBins number of rate bins
         */
        RateBinInfoPtr getRateBins(int numBins);
        /**
         * Combines the computations of getCellRates and getRateBins.
         * @param[in] numBins number of rate bins
         */
        CellRateBinInfoPtr getRatesWithBins(int numBins);
        /**
         * Return a PopulationBurstingInfoPtr storing bursts data for each of the cells.
         *
         * @param[in] significance threshold probability for burst detection, signifiying spiking significantly higher than Poisson.
         */
        PopulationBurstingInfoPtr getBursting(double significance);
        /**
         * Return a SynchronyInfoPtr with the average population SPIKE-distance, computed 
         * as an average over each of the pairwise synchrony values
         */
        SynchronyInfoPtr getPopulationSynchrony();
        /**
         * Return a SynchronyInfoPtr with the SPIKE-distance metric between two cells.
         *
         * @param[in] idxCell1 index of first neuron.
         * @param[in] idxCell2 index of second neuron.
         */
        SynchronyInfoPtr getPairSynchrony(int idxCell1, int idxCell2);
        /**
         * Set the value returned for the synchrony of two empty spike trains.  The default value is 0, indicating full synchrony
                 * @param[in] val the value that is assigned to the synchrony of two empty spike trains
         */
        void setEmptyTrainSynchVal(double val);
        /**
         * Use the cellActivity structure to construct the spikeActivity structure.
         */
        void buildSpikeActFromCellAct();
        /**
         * Sort the spikeActivity structure when it is constructed out of order.
         */
        void sortSpikeActivity();
        /**
         * Return a pointer to the spikeActivity structure.
         */
        SpikeActivityPtr spikeActivity();
        /**
         * Return a pointer to the cellActivity structure.
         */
        CellActivityPtr cellActivity();
        /**
         * Return a pointer to the parameters.
         */
        NeuronParamsPtr paramsIn();
        /**
         * Set the parameter pointer to a new parameter object.
         *
         * @param[in] params a pointer to the new parameter object.
         */
        void setParamsIn(NeuronParamsPtr params);
        /**
         * Add a spike to the spikeActivity structure.
         *
         * @param[in] time the time for which a spike is added.
         * @param[in] time the cell index for which a spike is added.
         */
        void addSpike(int time, int index);
    protected:
        /**
         * Loop through each of the cells identifying periods of bursting using
         * the Poisson Surprise method from Hanes, Thompson, and Schall
         * (1995, Exp Brain Res 103:85-96).
         *
         * @param[in] the significance level for calculating Poisson surprise.
         * @param[out] structure to hold the identified bursts.
         */
        inline void calcBursting(double significance, std::vector<std::vector<BurstInfo> > *burstResults);
        /**
         * Bivariate Spike dissimilarity for cells in the structure using the SPIKE method from:
         *      Kreuz T, Chicharro D, Houghton C, Andrzejak RG, Mormann F: Monitoring spike train synchrony. Submitted (2012).
         *      Kreuz T: Measures of spike train synchrony. Scholarpedia, 6(10):11934 (2011).
         *
         * @param[in] index for first cell in the cellActivity structure.
         * @param[in] index for second cell in the cellActivity structure.
         * @param[out] Spike dissimilarity output.
         *
         */
        inline void calcPairSynchrony(int idxCell1, int idxCell2, std::vector<double> *S);
        /**
         * Bivariate Spike dissimilarity between two spike trains using the SPIKE method from:
         *      Kreuz T, Chicharro D, Houghton C, Andrzejak RG, Mormann F: Monitoring spike train synchrony. Submitted (2012).
         *      Kreuz T: Measures of spike train synchrony. Scholarpedia, 6(10):11934 (2011).
         *
         * @param[in] first spike train.
         * @param[in] second spike train.
         * @param[out] Spike dissimilarity output
         *
         */
        inline void calcPairSynchronywSpikes(std::vector<int> *spikeTrain1, std::vector<int> *spikeTrain2, std::vector<double> *S);
        /**
         * Multivariate Spike dissimilarity using the SPIKE method from:
         *      Kreuz T, Chicharro D, Houghton C, Andrzejak RG, Mormann F: Monitoring spike train synchrony. Submitted (2012).
         *      Kreuz T: Measures of spike train synchrony. Scholarpedia, 6(10):11934 (2011).
         *
         * @param[out] Spike dissimilarity output for the entire population
         *
         */
        inline void calcPopulationSynchrony(std::vector<double> *S);
        /**
         * Calculate the individual cell spike count averages over the given time interval.
         * This will also keep track of the maximum rate.
         *
         * @param[out] cells a pointer to where the cell indexes collected will be stored.
         * @param[out] rates a pointer to where the rates for each cell will be stored.
         * @param[out] maxRate a reference to the variable where the maximum rate will be stored.
         */
        inline void calcCellRates(std::vector<int> *cells, std::vector<double> *rates, double &maxRate);
        /**
         * Calculate the individual cell spike count averages over the given time interval.
         *
         * @param[out] cells a pointer to where the cell indexes collected will be stored.
         * @param[out] rates a pointer to where the rates for each cell will be stored.
         */
        inline void calcCellRates(std::vector<int> *cells, std::vector<double> *rates);
        /**
         * Create a count of the number of cells with average spike counts within a particular bin.
         * This assumes that @calcCellRates has not been called yet.
         *
         * @param[in] bumBins the number of bins to use to split the entire frequency range.
         * @param[out] freqs pointer to the vector to store the bin end frequency.
         * @param[out] count pointer to the vector containing the corresponding counts.
         *
         */
        inline void calcRateBins(int numBins, std::vector<double> *freqs,std::vector<int> *count);
        /**
         * Approximate the fire rate of the population using a binned window and counting the spikes.
         *
         * @param[in] step how far in time (ms) to move the window after each calculation.
         * @param[in] rateWindow the size of the window in (ms).
         * @param[out] rates a pointer to the vector that will store the rate for that window.
         *
         */
        inline void calcWindowRate(double step, double rateWindow, std::vector<double> *rates);
        /**
         * Approximate the fire rate of the population using a Gaussian window function.
         *
         * @param[in] step how far to slide the window after each calculation.
         * @param[in] rateWindow corresponds to sigma_w in the Gaussian weight function.
         * @param[out] rates a pointer to the vector that will store the rate for that window.
         *
         */
        inline void calcGaussWindowRate(double step, double rateWindow, std::vector<double> *rates);
        /**
         * Create separate vectors for spiking information so it can be easily plotted.
         *
         * @param[out] time a pointer the vector that will store the time (ms).
         * @param[out] spikes a pointer to the vector that will store a neuron index representing a spike ad the cooresponding time.
         */
        inline void calcSpikeTimes(std::vector<int> *time, std::vector<int> *spikes);
        /**
         * Calculate the coefficient of variation (C_v = stand_dev(isi) / mean(isi)) for cells that had more than 10 spikes in the given interval.
         *
         * @param[out] cells a pointer to the vector to store the cell indexes.
         * @param[out] COV a pointer to the vectore containing the corresponding COV calculations.
         */
        inline void calcCOV(std::vector<int> *cells, std::vector<double> *COV);
        /**
         * Computes both the individual cell average spike counts and the overall population binned activity
         *
         * @param[in] bumBins the number of bins to use to split the entire frequency range.
         * @param[out] cells a pointer to where the cell indexes collected will be stored.
         * @param[out] rates a pointer to where the rates for each cell will be stored.
         * @param[out] freqs pointer to the vector to store the bin end frequency.
         * @param[out] count pointer to the vector containing the corresponding counts.
         *
         */
        inline void calcRatesWithBins(int numBins, std::vector<int> *cells, std::vector<double> *rates,std::vector<double> *freqs,std::vector<int> *count);
        /**
         * Try to build the internal structures if they have not been constructed.
         */
        inline void checkDataStructures();
    public:
        virtual void clearDataStructures();
        SpikeActivityPtr spikeActivity_;
        CellActivityPtr cellActivity_;
        NeuronParamsPtr paramsIn_;
        double emptyTrainSynchVal;
    private:
        double calcMaxRate();
        std::vector<int>::iterator getSubBurstPeriodEnd(std::vector<int> *spikes, std::vector<int>::iterator searchStartPoint, double spikeRate);
        double calcSynchrony(CellSynchronyInfoPtr cell1Info, CellSynchronyInfoPtr cell2Info);
        friend class boost::serialization::access;
        template<typename Archive>
        void serialize(Archive& ar, const unsigned int version) {
            (void)version;
            ar & spikeActivity_ & cellActivity_ & paramsIn_ & emptyTrainSynchVal;
        }
};

typedef boost::shared_ptr<HrlNeuralAnalysis> HrlNeuralAnalysisPtr;

}

#endif /* HRLNEURALANALYSIS_H */
