/*
    HRLAnalysis(TM) Software License - Version 1.0 - August 27th, 2013

    Permission is hereby granted, free of charge, to any person or
    organization obtaining a copy of the software and accompanying
    documentation covered by this license (the "Software") to use,
    reproduce, display, distribute, execute, and transmit the
    Software, and to prepare derivative works of the Software, and
    to permit third-parties to whom the Software is furnished to do
    so, all subject to the following:

    The copyright notices in the Software and this entire statement,
    including the above license grant, this restriction and the
    following disclaimer, must be included in all copies of the
    Software, in whole or in part, and all derivative works of the
    Software, unless such copies or derivative works are solely in
    the form of machine-executable object code generated by a source
    language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
    NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
    ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR
    OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE, INCLUDING BUT NOT LIMITED TO THE
    COMPATIBILITY OF THIS LICENSE WITH OTHER SOFTWARE LICENSES.
*/
#include <HrlAnalysisUtilities.h>

//using namespace hrlAnalysis;
//using namespace std;

namespace hrlAnalysis {

StateDistancePtr calcStateDistance(PopFilterInfoPtr data1, PopFilterInfoPtr data2) {
	int numCells = data1->states.size();
	int timeLength = data1->states.at(0).size();

	StateDistancePtr distance(new StateDistance);
	distance->state.reserve(timeLength);

	if((data1->states.size() == data2->states.size()) &&
	   (data1->states.at(0).size() == data2->states.at(0).size()) ) {
		for(int t = 0; t < timeLength; t++) {
			// Calculate the sum of squares of the differences at this time.
			double tempDist = 0;
			for(int cell = 0; cell < numCells; cell++) {
				double diff = data1->states.at(cell).at(t) - data2->states.at(cell).at(t);
				tempDist += diff*diff;
			}
			distance->state.push_back(sqrt(tempDist));
		}
	}
	return distance;
}

// Untested.
StateDistancePtr calcStateDistanceWithin(PopFilterInfoPtr data1) {
	int numCells = data1->states.size();
	int timeLength = data1->states.at(0).size();

	StateDistancePtr distance(new StateDistance);
	distance->state.reserve(timeLength);

    for(int t = 0; t < timeLength; t++) {
        // Calculate the sum of squares of the differences at this time.
        double tempDist = 0;
        for(int cellIdx1 = 0; cellIdx1 < numCells; cellIdx1++) {
            for(int cellIdx2 = cellIdx1; cellIdx2 < numCells; cellIdx2++) {
                double diff = data1->states.at(cellIdx1).at(t) - data1->states.at(cellIdx2).at(t);
                tempDist += diff*diff;
            }                
        }
        distance->state.push_back(sqrt(tempDist));
    }

	return distance;
}



}

