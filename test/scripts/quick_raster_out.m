% HRLAnalysis(TM) Software License - Version 1.0 - August 27th, 2013
% 
% Permission is hereby granted, free of charge, to any person or 
% organization obtaining a copy of the software and accompanying 
% documentation covered by this license (the "Software") to use, 
% reproduce, display, distribute, execute, and transmit the 
% Software, and to prepare derivative works of the Software, and 
% to permit third-parties to whom the Software is furnished to do 
% so, all subject to the following:
% 
% The copyright notices in the Software and this entire statement, 
% including the above license grant, this restriction and the 
% following disclaimer, must be included in all copies of the 
% Software, in whole or in part, and all derivative works of the 
% Software, unless such copies or derivative works are solely in 
% the form of machine-executable object code generated by a source 
% language processor.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
% EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
% OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND 
% NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR 
% ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR 
% OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING 
% FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
% OTHER DEALINGS IN THE SOFTWARE, INCLUDING BUT NOT LIMITED TO THE 
% COMPATIBILITY OF THIS LICENSE WITH OTHER SOFTWARE LICENSES.
%
function [out, cell_spike_rates] = quick_raster_out(strFile, prefix, ...
                                                    calc_rates, ... 
                                                    plot_raster, num_cells, ...
                                                    rate_window, ...
                                                    time_range)
    % MATLAB
    %out = importdata(strFile);

    %Octave
    out = load(strFile);

    if(size(out,1) == 0)
        return;
    end;
    
    subplot(5,4,[1 7]);
    % Reduce the information to the region we're interested in (indexes we want to keep).
    % Just grab the excitatory cells
    % Min
    %out = out((out(:,2) > exc_max(1)+1), :);
    % Max
    %out = out((out(:,2) < exc_max(2)+1), :);
    % Grab the times we want.    
    % Min Time
    out = out((out(:,1) > time_range(1)+1), :);
    % Max Time
    out = out((out(:,1) < time_range(2)+1), :);
    
    if(plot_raster == 1)
        % Plot the raster.
        plot(out(:,1), out(:,2), '.k');
        %set(gca,'xtick',[]);
        ylabel('Cell Index');
        save( sprintf('%sraster.dat', prefix), 'out', '-ascii', '-tabs')
    end;
    % Compute the time we're interested in.
    sim_time = time_range(2) - time_range(1);
   
    
    %----------------------------------------------------------------------
    % The "out" matrix contains a column of times in ms and a column of
    % cell indexes indicating the cell fired at that time.  So there will
    % be times repeated when mulitple cells fire.
    %----------------------------------------------------------------------
    % Calculate the spike rate information.
    if(calc_rates == 1)
        
        %------------------------------------------------------------------
        % Start on a per cell basis.
        %------------------------------------------------------------------
        % Calculate the max cell index.
        Min_Cell_Index = min(out(:,2));
        Max_Cell_Index = max(out(:,2));
        Max_Index = Max_Cell_Index - Min_Cell_Index + 1;
        % Create our storage container.
        cell_spike_rates = zeros(Max_Index,1);
        % Loop through and get the frequency for each cell.
        
        for i = 1:Max_Index
            cell_spike_rates(i) = ( length(find(out(:,2) == i + Min_Cell_Index - 1)) / sim_time )*1000;
        end;
        
        % plot the single cell spike rates.
        subplot(5,4,[4 16]);
        plot_range = [Min_Cell_Index:Max_Cell_Index];
        barh(plot_range, cell_spike_rates);                
        axis tight;
        xlabel('Freq. (Hz)');
        ylabel('Cell Index');
        
        % Combine the plot_range and cell_spikes to write to the file.
        spike_rates = [plot_range(:) cell_spike_rates(:)];
        save( sprintf('%sspike_rates.dat', prefix), 'spike_rates', '-ascii', '-tabs');
        
        
        % Calculate the mean spike rate.
        cell_spike_average = mean(cell_spike_rates);
        
        % bin the spike rates.
        spike_max = max(cell_spike_rates);
        freqs = [0:spike_max/50:spike_max];
        spike_bin = histc(cell_spike_rates,freqs);
        
        % Plote the result
        subplot(5,4,[17 19]);
        bar(freqs,spike_bin);
        axis tight;
        title(['Mean spike rate: ', num2str(cell_spike_average)]);
        xlabel('Freq. (Hz)');
        ylabel('Number of Cells');
        
        % Combine and write out.
        bins = [freqs(:) spike_bin(:)];
        save( sprintf('%sspike_bins.dat', prefix), 'bins', '-ascii', '-tabs');
        
        %------------------------------------------------------------------
        % Calculate activity along the rate window.
        %------------------------------------------------------------------
        
        % Change this to a moving window.
        
        % Calculate the number of bins.
        num_bins = sim_time/rate_window;
        
        % Create our container.
        spike_rate = zeros(num_bins,1);
        curr_pos = time_range(1);
        for curr_window = 1:num_bins
            for i = curr_pos:curr_pos + rate_window - 1
                spike_rate(curr_window) = spike_rate(curr_window) + ...
                                          (length(find(out(:,1) == i))/(   num_cells*(rate_window/1000)  ));
            end;
            curr_pos = curr_pos + rate_window;
        end;
        subplot(5,4,[9 11]);
        t = [0:(rate_window/1000):((sim_time-1)/1000)];        
        plot(t,spike_rate);
        set(gca,'xtickMode', 'auto');
        xlabel('Time (ms)');
        ylabel('Freq. (Hz)');     
        % Combine and write out.
        
        rates = [t(:) spike_rate(:)];
        save( sprintf('%swindow_rates.dat', prefix), 'rates', '-ascii', '-tabs');

        %------------------------------------------------------------------
        % Calculate activity along spikes/s a gaussian rate window. 
        % (C++ Style so it's not efficient)
        %------------------------------------------------------------------

        % Create our container.
        gauss_spike_rate  = zeros(num_bins,1);
        sigma = rate_window/1000;
        a = 1/(sqrt(2*pi)*sigma);
        b = (2*sigma^2);
        curr_pos = time_range(1) + rate_window/2;
        for curr_window = 1:num_bins
            bin_start = (curr_pos-4*rate_window+1);
            bin_end = (curr_pos + 4*rate_window);

            if(bin_start < 1)
                bin_start = 1;
            end;

            if(bin_end > time_range(2))
                bin_end = time_range(2);
            end;


            for i = bin_start:bin_end
                spikeTimes = find(out(:,1) == i);
                tau = ((curr_window*rate_window)-out(spikeTimes,1))./1000;
                gauss_spike_rate(curr_window,1) = gauss_spike_rate(curr_window,1) + sum((a * exp(-(tau.^2)/b)));

            end;
            gauss_spike_rate(curr_window,1) = gauss_spike_rate(curr_window,1)/(num_cells);
            curr_pos = curr_pos + rate_window;

        end;
   
        gauss_spike_rate_2 = gauss_spike_rate;

        subplot(6,4,[13 15]);
        t = [0:(rate_window/1000):((sim_time-1)/1000)];        
        plot(t,gauss_spike_rate);
        set(gca,'xtickMode', 'auto');
        xlabel('Time (ms)');
        ylabel('Freq. (Hz)');

        rates = [t(:) gauss_spike_rate(:)];
        save( sprintf('%sgauss_window_rates.dat', prefix), 'rates', '-ascii', '-tabs');
        

    end
    
