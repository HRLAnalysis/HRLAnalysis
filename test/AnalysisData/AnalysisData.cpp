/*
    HRLAnalysis(TM) Software License - Version 1.0 - August 27th, 2013

    Permission is hereby granted, free of charge, to any person or 
    organization obtaining a copy of the software and accompanying 
    documentation covered by this license (the "Software") to use, 
    reproduce, display, distribute, execute, and transmit the 
    Software, and to prepare derivative works of the Software, and 
    to permit third-parties to whom the Software is furnished to do 
    so, all subject to the following:

    The copyright notices in the Software and this entire statement, 
    including the above license grant, this restriction and the 
    following disclaimer, must be included in all copies of the 
    Software, in whole or in part, and all derivative works of the 
    Software, unless such copies or derivative works are solely in 
    the form of machine-executable object code generated by a source 
    language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND 
    NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR 
    ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR 
    OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING 
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
    OTHER DEALINGS IN THE SOFTWARE, INCLUDING BUT NOT LIMITED TO THE 
    COMPATIBILITY OF THIS LICENSE WITH OTHER SOFTWARE LICENSES.
*/
#include <AnalysisData.h>

using namespace std;

// Constructors

AnalysisData::AnalysisData() {

}

AnalysisData::~AnalysisData() {
    rasterData_.clear();
    spikeBins_.clear();
    spikeRates_.clear();
    windowRates_.clear();
    COV_.clear();
    voltageData_.clear();
}

// Public Functions

bool AnalysisData::fillRasterData(std::string fileName) {
    rasterData_.clear();
    return fillData(rasterData_,fileName);
}

bool AnalysisData::fillSpikeBins(std::string fileName) {
    spikeBins_.clear();
    return fillData(spikeBins_,fileName);
}

bool AnalysisData::fillSpikeRates(std::string fileName) {
    spikeRates_.clear();
    return fillData(spikeRates_,fileName);
}

bool AnalysisData::fillWindowRates(std::string fileName) {
    windowRates_.clear();
    return fillData(windowRates_,fileName);
}

bool AnalysisData::fillCOV(std::string fileName) {
    COV_.clear();
    return fillData(COV_,fileName);
}

bool AnalysisData::fillVoltageData(std::string fileName) {
    voltageData_.clear();
    std::vector< std::vector<float> > vData;
    bool success = fillData(vData,fileName);
    if (success) {
      /*
       *VoltageData_ is stored as a cell-major structure,
       *but the voltage files are written as time-major.
       * ---> Fill voltageData_ by transposing vData
       */

      // resize voltageData_ to store vData's transpose
      voltageData_.resize(vData[0].size());
      for (int idx = 0; idx < voltageData_.size(); idx++)
        voltageData_[idx].resize(vData.size());
         
      // copy elements
      for (int time = 0; time < vData.size(); time++)
        for (int cell = 0; cell < vData[time].size(); cell++)
          voltageData_[cell][time] = vData[time][cell];

    }
    return success;
}

bool AnalysisData::compareSpikeBinsAt(std::vector<int> &data, int loc) {
    bool retVal;
    if(loc == 0) {
        retVal = spikeBins_.at(0).second == data.at(0);
    } else {
        retVal = spikeBins_.back().second == data.back();
    }
    return retVal;
}

bool AnalysisData::compareRasterData(std::vector<std::pair<int,int> > &data) {
    return compareData(rasterData_, data);
}

bool AnalysisData::compareSpikeBins(std::vector<std::pair<int,int> > &data) {
    return compareData(spikeBins_, data);
}

bool AnalysisData::compareSpikeRates(std::vector<std::pair<int,double> > &data) {
    return compareData(spikeRates_, data);
}

bool AnalysisData::compareWindowRates(std::vector<std::pair<int,double> > &data) {
    return compareData(windowRates_, data);
}

bool AnalysisData::compareRasterData(std::vector<int> &data, int dimension) {
    return compareData(rasterData_, data, dimension);
}

bool AnalysisData::compareSpikeBins(std::vector<int> &data, int dimension) {
    return compareData(spikeBins_, data, dimension);
}

bool AnalysisData::compareSpikeRates(std::vector<int> &data) {
    return compareData(spikeRates_, data);
}

bool AnalysisData::compareWindowRates(std::vector<int> &data) {
    return compareData(windowRates_, data);
}

bool AnalysisData::compareSpikeRates(std::vector<double> &data) {
    return compareData(spikeRates_, data);
}

bool AnalysisData::compareWindowRates(std::vector<double> &data) {
    return compareData(windowRates_, data);
}

bool AnalysisData::compareCOV(std::vector<double> &data) {
    return compareData(COV_, data);
}

bool AnalysisData::compareVoltageData(std::vector< std::vector<float> > &data, float tol) {
    return compareData(voltageData_, data, tol);
}

/*
void AnalysisData::dumpRaster() {
    for_each(rasterData_.begin(), rasterData_.end(), AnalysisData::printIntPair);
}

void AnalysisData::dumpSpikeBins(){
    for_each(spikeBins_.begin(), spikeBins_.end(), AnalysisData::printIntPair);
}

void AnalysisData::dumpSpikeRates(){
    for_each(spikeRates_.begin(), spikeRates_.end(), AnalysisData::printDblPair);
}

void AnalysisData::dumpWindowRates(){
    for_each(spikeRates_.begin(), spikeRates_.end(), AnalysisData::printDblPair);
}
*/



// Private Functions

bool AnalysisData::fillData(std::vector<std::pair<int,int> > &data, std::string fileName) {
    bool retVal = false;
    double timeIn;
    double dataIn;

    ifstream fpIn(fileName.c_str(), ios::in);

    if(!fpIn.fail()) {
        while(fpIn.good()) {
            fpIn >> timeIn;
            fpIn >> dataIn;
            if(!fpIn.eof()) {
                data.push_back(make_pair(timeIn,dataIn));  // HACK: It seems really bad to not cast these to ints.
                //cout << "\t insert pair: \t" << timeIn << "\t" << dataIn << endl;
            }
        }
        retVal = true;
    } else {
        cerr << "Failed to correctly open file: \n\t" << fileName << endl;
    }

    fpIn.close();

    //for_each(data.begin(), data.end(), AnalysisData::printIntPair);

    return retVal;
}

bool AnalysisData::fillData(std::vector<std::pair<int,double> > &data, std::string fileName) {
    bool retVal = false;
    double timeIn;
    double dataIn;

    ifstream fpIn(fileName.c_str(), ios::in);

    if(!fpIn.fail()) {
        while(fpIn.good()) {
            fpIn >> timeIn;
            fpIn >> dataIn;
            if(!fpIn.eof()) {
                data.push_back(make_pair(timeIn,dataIn));
            }
        }
        retVal = true;
    }
    fpIn.close();
    //for_each(data.begin(), data.end(), AnalysisData::printIntPair);
    return retVal;
}


bool AnalysisData::fillData(std::vector< std::vector<float> > &data, std::string fileName) {
    bool retVal = false;

    ifstream fpIn(fileName.c_str(), ios::in);
    string   line;
    int row = 0;

    if(!fpIn.fail()) {

      // Read one line at a time into the variable line:
      while(std::getline(fpIn, line)) {
        std::stringstream  linestream(line);
        std::vector<float>   lineData;

        float value;
        // Read one float at a time from the line
        while(linestream >> value)
        {
          // Add the float from the line to a vector
          lineData.push_back(value);
        }
        // When all the floats have been read, add the vector
        // to the data structure
        data.push_back(lineData);
      }
      retVal = true;
    } else {
      cerr << "Failed to correctly open file: \n\t" << fileName << endl;
    }

    fpIn.close();

    return retVal;
}

void AnalysisData::printIntPair(pair<int,int> iPair) {
    cout << "\t" << iPair.first << "\t" << iPair.second << std::endl;
}

void AnalysisData::printDblPair(pair<int,double> iPair) {
    cout << "\t" << iPair.first << "\t" << iPair.second << std::endl;
}

bool AnalysisData::compareData(std::vector<std::pair<int,int> > &data1, std::vector<std::pair<int,int> > &data2) {
    bool retVal = true;
    int currentLine = 1;
    std::vector<std::pair<int,int> >::iterator data1It = data1.begin();
    std::vector<std::pair<int,int> >::iterator data2It = data2.begin();

    // Check the length
    if(data1.size() != data2.size()) {
        retVal = false;
        cout << "\t\tVector sizes do not match!\tdata1: " << data1.size() << "\t" << data2.size() << endl;
    } else {
        while(data1It != data1.end() && data2It != data2.end() && retVal ) {
            // Compare the elements
            if( (data1It->first != data2It->first) || (data1It->second != data2It->second)) {
                retVal = false;
                cout << "\t\tVectors do not match at item " << currentLine << endl;
                cout << "\t\t\tData1 pair \t" << data1It->first << "\t" << data1It->second << endl;
                cout << "\t\t\tData2 pair \t" << data2It->first << "\t" << data2It->second << endl;
            }
            // Increment the iterators and the current line.
            ++data1It;
            ++data2It;
            ++currentLine;
        }
    }

    return retVal;

}

bool AnalysisData::compareData(std::vector<std::pair<int,double> > &data1, std::vector<std::pair<int,double> > &data2) {
    bool retVal = true;
    int currentLine = 1;
    std::vector<std::pair<int,double> >::iterator data1It = data1.begin();
    std::vector<std::pair<int,double> >::iterator data2It = data2.begin();

    // Check the length
    if(data1.size() != data2.size()) {
        retVal = false;
        cout << "\t\tVector sizes do not match!\tdata1: " << data1.size() << "\t" << data2.size() << endl;
    } else {
        while(data1It != data1.end() && data2It != data2.end() && retVal ) {
            // Compare the elements
            if( (data1It->first != data2It->first) ||
                fabs(data1It->second - data2It->second) > TOLERANCE) {
                retVal = false;
                cout << "\t\tVectors do not match at item " << currentLine << endl;
                cout << "\t\t\tData1 pair \t" << data1It->first << "\t" << data1It->second << endl;
                cout << "\t\t\tData2 pair \t" << data2It->first << "\t" << data2It->second << endl;
            }
            // Increment the iterators and the current line.
            ++data1It;
            ++data2It;
            ++currentLine;
        }
    }
    return retVal;
}

bool AnalysisData::compareData(std::vector<std::pair<int,int> > &data1, std::vector<int> &data2, int dimension) {
    bool retVal = true;
    int currentLine = 1;
    std::vector<std::pair<int,int> >::iterator data1It = data1.begin();
    std::vector<int>::iterator data2It = data2.begin();

    // Check the length
    if(data1.size() != data2.size()) {
        retVal = false;
        cout << "\t\tVector sizes do not match!\tdata1: " << data1.size() << "\t" << data2.size() << endl;
    } else {
        while(data1It != data1.end() && data2It != data2.end() && retVal ) {
            // Compare the elements
            if( ((data1It->first != *data2It) && dimension == 1) ||
                ((data1It->second != *data2It) && dimension == 2) ) {
                retVal = false;
                cout << "\t\tVectors do not match at item " << currentLine << endl;
                cout << "\t\t\tData1 pair \t" << data1It->first << "\t" << data1It->second << endl;
                cout << "\t\t\tData2 \t" << *data2It << endl;
            }
            // Increment the iterators and the current line.
            ++data1It;
            ++data2It;
            ++currentLine;
        }
    }
    return retVal;
}

bool AnalysisData::compareData(std::vector<std::pair<int,double> > &data1, std::vector<double> &data2) {
    bool retVal = true;
    int currentLine = 1;
    std::vector<std::pair<int,double> >::iterator data1It = data1.begin();
    std::vector<double>::iterator data2It = data2.begin();

    // Check the length
    if(data1.size() != data2.size()) {
        retVal = false;
        cout << "\t\tVector sizes do not match!\tdata1: " << data1.size() << "\t" << data2.size() << endl;
    } else {
        while(data1It != data1.end() && data2It != data2.end() && retVal ) {
            // Compare the elements
            if( (fabs(data1It->second - *data2It) > TOLERANCE) ) {
                retVal = false;
                cout << "\t\tVectors do not match at item " << currentLine << endl;
                cout << "\t\t\tData1 pair \t" << data1It->first << "\t" << data1It->second << endl;
                cout << "\t\t\tData2 pair \t" << *data2It << endl;
            }
            // Increment the iterators and the current line.
            ++data1It;
            ++data2It;
            ++currentLine;
        }
    }
    return retVal;
}

bool AnalysisData::compareData(std::vector<std::pair<int,double> > &data1, std::vector<int> &data2) {
    bool retVal = true;
    int currentLine = 1;
    std::vector<std::pair<int,double> >::iterator data1It = data1.begin();
    std::vector<int>::iterator data2It = data2.begin();

    // Check the length
    if(data1.size() != data2.size()) {
        retVal = false;
        cout << "\t\tVector sizes do not match!\tdata1: " << data1.size() << "\t" << data2.size() << endl;
    } else {
        while(data1It != data1.end() && data2It != data2.end() && retVal ) {
            // Compare the elements
            if( data1It->first != *data2It ) {
                retVal = false;
                cout << "\t\tVectors do not match at item " << currentLine << endl;
                cout << "\t\t\tData1 pair \t" << data1It->first << "\t" << data1It->second << endl;
                cout << "\t\t\tData2 pair \t" << *data2It << endl;
            }
            // Increment the iterators and the current line.
            ++data1It;
            ++data2It;
            ++currentLine;
        }
    }
    return retVal;
}

bool AnalysisData::compareData(std::vector<float> &data1, std::vector<float> &data2, float tol) {
    bool retVal = true;
    int currentLine = 1;
    std::vector<float>::iterator data1It = data1.begin();
    std::vector<float>::iterator data2It = data2.begin();

    // Check the length
    if(data1.size() != data2.size()) {
        retVal = false;
        cout << "\t\tVector lengths do not match!\tdata1: " << data1.size() << "\tdata2:" << data2.size() << endl;
    } else {
        while(data1It != data1.end() && data2It != data2.end() && retVal ) {
            // Compare the elements
          if( fabs(*data1It - *data2It) > tol ) {
                retVal = false;
                cout << "\t\tVectors do not match at item " << currentLine << endl;
                cout << "\t\t\tData1 element \t" << *data1It << endl;
                cout << "\t\t\tData2 element \t" << *data2It << endl;
            }
            // Increment the iterators and the current line.
            ++data1It;
            ++data2It;
            ++currentLine;
        }
    }
    return retVal;
}  


bool AnalysisData::compareData(std::vector< std::vector<float> > &data1, std::vector< std::vector<float> > &data2, float tol) {
    bool retVal = true;
    int currentLine = 1;
    std::vector< std::vector<float> >::iterator data1It = data1.begin();
    std::vector< std::vector<float> >::iterator data2It = data2.begin();

    // Check the length
    if(data1.size() != data2.size()) {
        retVal = false;
        cout << "\t\t2D vector rows do not match!\t2D-Data1: " << data1.size() << "\t2D-Data2:" << data2.size() << endl;
    } else {
        while(data1It != data1.end() && data2It != data2.end() && retVal ) {
            // Compare the elements
          if( !compareData(*data1It, *data2It, tol) ){
                retVal = false;
                cout << "\t\t2D vectors do not match at row " << currentLine << endl;
            }
            // Increment the iterators and the current line.
            ++data1It;
            ++data2It;
            ++currentLine;
        }
    }
    return retVal;
}  
