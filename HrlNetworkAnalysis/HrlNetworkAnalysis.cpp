/*
    HRLAnalysis(TM) Software License - Version 1.0 - August 27th, 2013

    Permission is hereby granted, free of charge, to any person or 
    organization obtaining a copy of the software and accompanying 
    documentation covered by this license (the "Software") to use, 
    reproduce, display, distribute, execute, and transmit the 
    Software, and to prepare derivative works of the Software, and 
    to permit third-parties to whom the Software is furnished to do 
    so, all subject to the following:

    The copyright notices in the Software and this entire statement, 
    including the above license grant, this restriction and the 
    following disclaimer, must be included in all copies of the 
    Software, in whole or in part, and all derivative works of the 
    Software, unless such copies or derivative works are solely in 
    the form of machine-executable object code generated by a source 
    language processor.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND 
    NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR 
    ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR 
    OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING 
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR 
    OTHER DEALINGS IN THE SOFTWARE, INCLUDING BUT NOT LIMITED TO THE 
    COMPATIBILITY OF THIS LICENSE WITH OTHER SOFTWARE LICENSES.
*/
#include <HrlNetworkAnalysis.h>

using namespace hrlAnalysis;
using namespace std;

HrlNetworkAnalysis::HrlNetworkAnalysis()
{}

HrlNetworkAnalysis::~HrlNetworkAnalysis()
{}


// Public

bool HrlNetworkAnalysis::buildNetwork(std::string fileName)
{

    //---------------------------------------------------------------------------------
    // Open network the file.

    std::ifstream in;
    in.open(fileName.c_str());
    if (not in.is_open()) {
        cerr << "Cannot open " << fileName << " for reading" << endl;
        return false;
    }

    readNetwork(in);

    if (not in.good()) {
        cerr << "Error reading network topology from Data/net.bin" << endl;
        return false;
    }
    in.close();
    //---------------------------------------------------------------------------------

    buildPopulationStats();

    return true;

}

void HrlNetworkAnalysis::outputGraph(std::string fileName)
{
    int numPopulations = populations_.size();
    std::ofstream of (fileName.c_str());
    if(of.is_open()) {
        // Open Digraph
        of << "digraph G {" << endl;
        of << "\tnode [style=filled,color=chartreuse4];" << endl;
        //of << "size=\"8,5\"" << endl;
        for(int popIdx = 0; popIdx < numPopulations; popIdx++) {
            of << "\tPop" << popIdx << " [ ";
            of << "label = \"" << populations_.at(popIdx).strName;
            of << " \\n(" << populations_.at(popIdx).size << " neurons)\"";

            if(populations_.at(popIdx).inhibitory)
                of << ", color=firebrick, shape=rect";
            else
                of << ", color=chartreuse4";

            of << "];" << endl;
        }

        for(int postPopulation = 0; postPopulation < numPopulations; postPopulation++) {
            for(int prePopulation = 0; prePopulation < numPopulations; prePopulation++) {
                if(!populations_.at(postPopulation).dummy) {
                    if(populations_.at(prePopulation).excConnectionCount.at(postPopulation).connectionCount > 0) {
                        of << "\tPop" << prePopulation;
                        of << " -> ";
                        of << "Pop" << postPopulation;
                        of << "[label = \"N=" << populations_.at(prePopulation).excConnectionCount.at(postPopulation).connectionCount;
                        of << "\\ng=" << populations_.at(prePopulation).excConnectionCount.at(postPopulation).avgWeight.front();
                        of << "\"];";
                        of << endl;
                    }
                }
            }
        }

        // Close Digraph
        of << "}" << endl;

        of.close();
    }
}

void HrlNetworkAnalysis::outputWeights (std::string populationFileName, std::string weightFileName)
{

    int numPopulations = populations_.size();
    std::ofstream of (populationFileName.c_str());
    if(of.is_open()) {

        of << "\t\tPre:" << endl << "\t\t";
        for(int popIdx = 0; popIdx < numPopulations; popIdx++) {
            of << populations_.at(popIdx).strName << "\t";
        }

        of.close();

    }

    std::ofstream of2(weightFileName.c_str());
    if(of2.is_open()) {
        for(int postPopulation = 0; postPopulation < numPopulations; postPopulation++) {
            if(!populations_.at(postPopulation).dummy) {
                //of2 << "\t" << populations_.at(postPopulation).strName;
                for(int prePopulation = 0; prePopulation < numPopulations; prePopulation++) {
                    if(populations_.at(prePopulation).excConnectionCount.at(postPopulation).connectionCount > 0) {
                        of2 << "\t";
                        of2 << populations_.at(prePopulation).excConnectionCount.at(postPopulation).avgWeight.front();
                    } else {
                        of2 << "\t-1";
                    }
                }
                of2 << endl;
            }
        }
        of2.close();
    }
    return;
}

void HrlNetworkAnalysis::addPopulation(std::string popName, uint startIdx, uint endIdx)
{
    populationInfo newPopulation;
    newPopulation.strName = popName;
    newPopulation.startIdx = startIdx;
    newPopulation.endIdx = endIdx;
    newPopulation.dummy = false;
    newPopulation.size = endIdx - startIdx + 1;
    
    LOG(NETWORKLog, logLEVEL1) << "Add population " << popName << " (" << startIdx << "," << endIdx << ") " << newPopulation.size << std::endl;

    populations_.push_back(newPopulation);
}

void HrlNetworkAnalysis::addDummyPopulation(std::string popName, uint startIdx, uint endIdx)
{
    populationInfo newPopulation;
    newPopulation.strName = popName;
    newPopulation.startIdx = startIdx;
    newPopulation.endIdx = endIdx;
    newPopulation.dummy = true;
    newPopulation.size = endIdx - startIdx + 1;
    
    LOG(NETWORKLog, logLEVEL1) << "Add population " << popName << " (" << startIdx << "," << endIdx << ")" << newPopulation.size << std::endl;

    populations_.push_back(newPopulation);
}

void HrlNetworkAnalysis::getWeights(std::string fileName)
{

    assert(sizeof(float) == 4);
    assert(sizeof(float[2]) == 8);

    LOG(NETWORKLog, logLEVEL1) << "fileName: " << fileName << endl;

    std::ifstream in;
    in.open(fileName.c_str());

    if (not in.is_open()) {
        cerr << "Can not open " << fileName.c_str() << " for reading" << endl;
        return;
    }

    float *g = new float[synTot_];
    in.read((char *)g, sizeof(float[synTot_]));
    in.close();

    std::vector<populationInfo>::iterator pop;
    std::vector<synapticInfo>::iterator synInfo;
    std::vector<std::pair<uint,uint> >::iterator synapsePair;

    float avgWeight;
    uint connectionCount;

    // Loop through the populations
    for(pop = populations_.begin() ; pop < populations_.end(); pop++) {
        // Loop through this population's connections
        for(synInfo = (*pop).excConnectionCount.begin(); synInfo < (*pop).excConnectionCount.end(); synInfo++) {
            // Now we have information on a particular population to population connection.  Get the synaptic information from the synapse index pairs.
            avgWeight = 0;
            connectionCount = 0;
            // The connections are stored in pairs since population order is lost when the synapse lists are sorted in the simulator.
            for(synapsePair = (*synInfo).synapses.begin(); synapsePair < (*synInfo).synapses.end(); synapsePair++ ) {
                for(uint i = (*synapsePair).first; i < (*synapsePair).second; i++) {
                    avgWeight += g[i];
                    ++connectionCount;
                }
            }
            // Make sure there were connections (the excConnectionCount vector is allocated with space for every population, some won't be connected).
            if(connectionCount > 0) {
                (*synInfo).avgWeight.push_back(avgWeight/(float)connectionCount );
                LOG(NETWORKLog, logLEVEL1) << "Adding synapse weight: " << synInfo->avgWeight.front() << std::endl;
            }
        }
    }
}

void HrlNetworkAnalysis::setLogToStd()
{
    SET_OUTPUT(NETWORKLog, stdout);
}

void HrlNetworkAnalysis::setLogToFile(std::string fileName)
{
    FILE* fNetworkOut;
    fNetworkOut = fopen(fileName.c_str(), "w");
    SET_OUTPUT(NETWORKLog, fNetworkOut);
}











// Private Functions

void HrlNetworkAnalysis::readNetwork(std::ifstream & in)
{

    byte *tempDelayIndex;

    // Based on the BuildNetwork constructor in State.cpp
    // Make sure that we're reading in what we think we
    // are.
    assert(sizeof(int) == 4);
    assert(sizeof(uint) == 4);
    assert(sizeof(int[2]) == 8);
    assert(sizeof(bool[2]) == 2);

    // Get the array sizes.
    in.read((char*)&numReal_, sizeof(int));
    in.read((char*)&numTot_, sizeof(int));
    in.read((char*)&synMax_, sizeof(uint));
    in.read((char*)&synTot_, sizeof(uint));

    // inp_offset holds the index where each neuron's presynaptic
    // neuron list starts.
    inputOffset_ = new int[numReal_];
    in.read((char*)inputOffset_, sizeof(int[numReal_]));

    // Lists how many presynaptic connections each neuron has.
    numInputs_ = new int[numReal_];
    in.read((char*)numInputs_, sizeof(int[numReal_]));

    // List of presynaptic neuron indexes.
    preIndex_ = new int[synTot_];
    in.read((char*)preIndex_, sizeof(int[synTot_]));

    // We don't really care about the delay index right now.
    tempDelayIndex = new byte[synTot_];
    in.read((char*)tempDelayIndex, sizeof(byte[synTot_]));

    // boolean list of whether or not the inputs are expected to be plastic.
    plasticInputs_ = new bool[numReal_];
    in.read((char*)plasticInputs_, sizeof(bool[numReal_]));

    // boolean list of whether or not the outputs are expected to be plastic.
    plasticOutputs_ = new bool[numTot_];
    in.read((char*)plasticOutputs_, sizeof(bool[numTot_]));

    // boolean list of whether or not the neuron is inhibitory.
    inhibitoryList_ = new bool[numTot_];
    in.read((char*)inhibitoryList_, sizeof(bool[numTot_]));



}

void HrlNetworkAnalysis::buildPopulationStats()
{
    // Start by filling in the population information.
    int numPopulations = populations_.size();
    std::vector<populationInfo>::iterator it;
    for(it = populations_.begin() ; it < populations_.end(); it++) {
        (*it).excConnectionCount.clear();
        (*it).excConnectionCount.resize(numPopulations);
        (*it).inhConnectionCount.clear();
        (*it).inhConnectionCount.resize(numPopulations);
    }

    // Loop thru each population and count the number of connections to them.
    for(int postPopulation = 0; postPopulation < numPopulations; postPopulation++) {
        if(!populations_.at(postPopulation).dummy) {
            for(int prePopulation = 0; prePopulation < numPopulations; prePopulation++) {
                    getSynapseCount(prePopulation, postPopulation);
            }
        } else {
            LOG(NETWORKLog, logLEVEL1) << "Population: " << postPopulation << "is a dummy population." << std::endl;
        }
    }
}





uint HrlNetworkAnalysis::binaryConnectionSearch(int preNeuronIdx, int postNeuronIdx)
{
    
    uint low = inputOffset_[postNeuronIdx];
    uint high = low + numInputs_[postNeuronIdx];
    if(high > synTot_) {
        LOG(NETWORKLog, logLEVEL1) << "Binary Search high too large: " << "low " << low << " high " << high << std::endl;
    } else {
        while (high > low) {
            uint mid = (low + high) / 2;
            if (preIndex_[mid] >= preNeuronIdx) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
    }
    return low;
}

void HrlNetworkAnalysis::getSynapseCount(int prePopulationIdx, int postPopulationIdx)
{

    LOG(NETWORKLog, logLEVEL1) << "Pre...";
    populationInfo prePopulation = populations_.at(prePopulationIdx);
    LOG(NETWORKLog, logLEVEL1) << "Post...";
    populationInfo postPopulation = populations_.at(postPopulationIdx);

    uint postSize = postPopulation.size;
    uint preSize = prePopulation.size;

    uint postIdxOffset = postPopulation.startIdx;
    uint preIdxOffset = prePopulation.startIdx;
    LOG(NETWORKLog, logLEVEL1) << "Reset...";
    populations_.at(prePopulationIdx).excConnectionCount.at(postPopulationIdx).connectionCount = 0;

    LOG(NETWORKLog, logLEVEL1) << "inhibitory?...";
    // Determine if the pre population is inhibitory.
    if(inhibitoryList_[preIdxOffset]) {
        populations_.at(prePopulationIdx).inhibitory = true;
    } else {
        populations_.at(prePopulationIdx).inhibitory = false;
    }
    LOG(NETWORKLog, logLEVEL1) << "Synapse Range Reset..." << std::endl;
    populations_.at(prePopulationIdx).excConnectionCount.at(postPopulationIdx).synStartIdx = UINT_MAX;
    populations_.at(prePopulationIdx).excConnectionCount.at(postPopulationIdx).synEndIdx = 0;

    // Count the synapses and set the starting and ending indexes for them.
    LOG(NETWORKLog, logLEVEL1) << "Getting connections from population: " << prePopulationIdx << "(offset: " << preIdxOffset << ",size: " << preSize << ")";
    LOG(NETWORKLog, logLEVEL1) << " to population: " << postPopulationIdx << "(offset: " << postIdxOffset << ",size: " << postSize << ")" << std::endl;

    for(uint postIdx = postIdxOffset; postIdx < postIdxOffset+postSize; postIdx++) {
        LOG(NETWORKLog, logLEVEL1) << "\tLooking for connections to post cell: " << postIdx << "...pre";
        LOG(NETWORKLog, logLEVEL1).flush();
        uint preStart = binaryConnectionSearch(preIdxOffset, postIdx);
        LOG(NETWORKLog, logLEVEL1) << "...post";
        LOG(NETWORKLog, logLEVEL1).flush();
        uint preEnd = binaryConnectionSearch(preIdxOffset+preSize, postIdx);
        LOG(NETWORKLog, logLEVEL1) << "...done." << std::endl;
        LOG(NETWORKLog, logLEVEL1).flush();
        // Make sure there was a connection.
        LOG(NETWORKLog, logLEVEL1) << "\tCompare: PreEnd = " << preEnd << " preStart = " << preStart << ", diff = " << (preEnd - preStart) << std::endl;
        LOG(NETWORKLog, logLEVEL1).flush();
        if((preEnd - preStart) > 0) {
            LOG(NETWORKLog, logLEVEL1) << "\t\tpreEnd-preStart > 0...";
            LOG(NETWORKLog, logLEVEL1).flush();
            populations_.at(prePopulationIdx).excConnectionCount.at(postPopulationIdx).connectionCount += (preEnd - preStart);
            LOG(NETWORKLog, logLEVEL1) << "Adding " << (preEnd - preStart) << " synapses. (" << preStart << "," << preEnd << ")" << std::endl;
            LOG(NETWORKLog, logLEVEL1).flush();
            populations_.at(prePopulationIdx).excConnectionCount.at(postPopulationIdx).synapses.push_back(std::make_pair(preStart,preEnd));
        } else {
            LOG(NETWORKLog, logLEVEL1) << "\t\tNot greater than 0." << std::endl;
            LOG(NETWORKLog, logLEVEL1).flush();
        }
    }
}



